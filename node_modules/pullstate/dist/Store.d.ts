import { Patch, PatchListener } from "immer";
import { DeepKeyOfArray, TAllPathsParameter } from "./useStoreStateOpt-types";
export declare type TPullstateUpdateListener = () => void;
export interface IStoreInternalOptions<S> {
    ssr: boolean;
    reactionCreators?: TReactionCreator<S>[];
}
export declare type TUpdateFunction<S> = (draft: S, original: S) => void;
declare type TPathReactionFunction<S> = (paths: TAllPathsParameter<S>, draft: S, original: S) => void;
declare type TReactionFunction<S, T> = (watched: T, draft: S, original: S, previousWatched: T) => void;
declare type TRunReactionFunction = () => string[];
declare type TReactionCreator<S> = (store: Store<S>) => TRunReactionFunction;
export declare type TStoreActionUpdate<S> = (updater: TUpdateFunction<S> | TUpdateFunction<S>[], patchesCallback?: (patches: Patch[], inversePatches: Patch[]) => void) => void;
export declare type TStoreAction<S> = (update: TStoreActionUpdate<S>) => void;
export declare class Store<S = any> {
    private updateListeners;
    private currentState;
    private batchState;
    private readonly initialState;
    private ssr;
    private reactions;
    private clientSubscriptions;
    private reactionCreators;
    private optimizedUpdateListeners;
    private optimizedUpdateListenerPaths;
    private optimizedListenerPropertyMap;
    _optListenerCount: number;
    _patchListeners: PatchListener[];
    constructor(initialState: S);
    _setInternalOptions({ ssr, reactionCreators }: IStoreInternalOptions<S>): void;
    _getReactionCreators(): TReactionCreator<S>[];
    _instantiateReactions(): void;
    _getInitialState(): S;
    _updateStateWithoutReaction(nextState: S): void;
    _updateState(nextState: S, updateKeyedPaths?: string[]): void;
    _addUpdateListener(listener: TPullstateUpdateListener): void;
    _addUpdateListenerOpt(listener: TPullstateUpdateListener, ordKey: string, paths: DeepKeyOfArray<S>[]): void;
    _removeUpdateListener(listener: TPullstateUpdateListener): void;
    _removeUpdateListenerOpt(ordKey: string): void;
    listenToPatches(patchListener: PatchListener): () => void;
    subscribe<T>(watch: (state: S) => T, listener: (watched: T, allState: S, previousWatched: T) => void): () => void;
    createReaction<T>(watch: (state: S) => T, reaction: TReactionFunction<S, T>): () => void;
    createPathReaction<T>(path: TAllPathsParameter<S>, reaction: TPathReactionFunction<S>): void;
    getRawState(): S;
    useState(): S;
    useState<SS = any>(getSubState: (state: S) => SS, deps?: ReadonlyArray<any>): SS;
    act(action: TStoreAction<S>): void;
    batch(updater: TUpdateFunction<S> | TUpdateFunction<S>[], patchesCallback?: (patches: Patch[], inversePatches: Patch[]) => void): void;
    flushBatch(ignoreError?: boolean): void;
    update(updater: TUpdateFunction<S> | TUpdateFunction<S>[], patchesCallback?: (patches: Patch[], inversePatches: Patch[]) => void): void;
    applyPatches(patches: Patch[]): void;
}
export declare function applyPatchesToStore<S = any>(store: Store<S>, patches: Patch[]): void;
export declare function update<S = any>(store: Store<S>, updater: TUpdateFunction<S> | TUpdateFunction<S>[], patchesCallback?: (patches: Patch[], inversePatches: Patch[]) => void): void;
export {};
